<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>记一次对mosn中dubbo、hessian-go的性能优化 | 诣极的博客</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="incubator-dubbo, dubbo, 后端开发, 全栈开发, javascript, java"><meta name="description" content="花名诣极，开源Apache Dubbo PMC。曾就职于阿里巴巴集团、有赞科技，担任dubbo框架技术负责人。目前就职于蚂蚁金服中间件团队，主攻rpc和Service mesh方向。 ''深入理解Apache Dubbo与实战''图书作者。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://zonghaishang.github.io/2020/06/02/记一次对mosn中dubbo、hessian-go的性能优化/index.html"><link rel="icon" type="image/png" href="null" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="诣极的博客"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(null)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="诣极的博客" alt="诣极的博客"><img src="/images/yiji.png" alt="诣极的博客"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/tags" alt="标签" title="标签">标签</a></li><li class="nav__item"><a href="/categories" alt="类别" title="类别">类别</a></li><li class="nav__item"><a href="https://github.com/zonghaishang" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/images/go.jpg" alt="记一次对mosn中dubbo、hessian-go的性能优化"></div><header class="post__info"><h1 class="post__title">记一次对mosn中dubbo、hessian-go的性能优化</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://github.com/zonghaishang">诣极</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2020-06-02</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/go/">Go</a></li><li class="mark__item"><a href="/tags/mosn/">Mosn</a></li><li class="mark__item"><a href="/tags/dubbo/">Dubbo</a></li></ul></div></div></header><div class="post__content"><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>蚂蚁内部对 service mesh 的稳定性和性能要求是比较高的，内部mosn 广泛用于生产环境。在云上和开源社区，RPC 领域dubbo和spring cloud 同样广泛用于生产环境，我们在 mosn 基础上，支持了 dubbo 和 spring cloud 流量代理。我们发现在支持 dubbo 协议过程中，经过 mesh 流量代理后，性能有非常大的性能损耗，在大商户落地mesh中也对性能有较高要求，因此本文会重点描述在基于 Go 语言库 <a href="https://github.com/apache/dubbo-go-hessian2" target="_blank" rel="noopener">dubbo-go-hessian2</a> 、dubbo协议中对<a href="https://github.com/mosn/mosn" target="_blank" rel="noopener">mosn</a>所做的性能优化。</p><h3 id="性能优化概述"><a href="#性能优化概述" class="headerlink" title="性能优化概述"></a>性能优化概述</h3><p>根据实际业务部署场景，并没有选用高性能机器，使用普通linux机器，配置和压测参数如下：</p><ul><li>Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHz 4核16G</li><li>pod配置 <code>2c、1g</code>，jvm参数 <code>-server -Xms1024m -Xmx1024m</code></li><li>网络延迟0.23ms, 2台linux机器，分别部署server+mosn, 压测程序<a href="https://github.com/zonghaishang/rpc-performance" target="_blank" rel="noopener">rpc-perfomance</a></li></ul><p>经过3轮性能优化后，使用优化版本mosn将会获得以下性能收益(框架随机512和1k字节压测)：</p><ul><li>512字节：mosn+dubbo服务调用tps整体提升55-82.8%，rt降低45%左右，内存占用40M</li><li>1k数据：mosn+dubbo服务调用tps整体提升51.1-69.3%，rt降低41%左右, 内存占用41M</li></ul><h3 id="性能优化工具pprof"><a href="#性能优化工具pprof" class="headerlink" title="性能优化工具pprof"></a>性能优化工具pprof</h3><p>磨刀不误砍柴工，在性能优化前首先要找到性能卡点，找到性能卡点后，另一个难点就是如何用高效代码优化替代slow code。因为蚂蚁service mesh是基于go语言实现的，我们首选go自带的pprof性能工具，我们简要介绍这个工具如何使用。如果我们go库自带http.Server时并且在main头部导入<code>import _ &quot;net/http/pprof&quot;</code>，go会帮我们挂载对应的handler, 详细可以参考<a href="https://pkg.go.dev/net/http/pprof?tab=doc" target="_blank" rel="noopener">godoc</a> 。</p><p>因为mosn默认会在<code>34902</code>端口暴露http服务，通过以下命令轻松获取mosn的性能诊断文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof -seconds 60 http://benchmark-server-ip:34902/debug/pprof/profile</span><br><span class="line"># 会生成类似以下文件，该命令采样cpu 60秒</span><br><span class="line"># pprof.mosn.samples.cpu.001.pb.gz</span><br></pre></td></tr></table></figure><p>然后继续用pprof打开诊断文件，方便在浏览器查看，在图1-1给出压测后profiler火焰图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># http=:8000代表pprof打开8000端口然后用于web浏览器分析</span><br><span class="line"># mosnd代表mosn的二进制可执行文件，用于分析代码符号</span><br><span class="line"># pprof.mosn.samples.cpu.001.pb.gz是cpu诊断文件</span><br><span class="line">go tool pprof -http=:8000 mosnd pprof.mosn.samples.cpu.001.pb.gz</span><br></pre></td></tr></table></figure><p><img src="/images/1-1.png" alt="mosn性能诊断火焰图"></p><center>图1-1 mosn性能压测火焰图</center><p>在获得诊断数据后，可以切到浏览器Flame Graph(火焰图，go 1.11以上版本自带)，火焰图的x轴坐标代表cpu消耗情况，y轴代码方法调用堆栈。在优化开始之前，我们借助go工具pprof可以诊断出大致的性能卡点在以下几个方面(直接压server端mosn)：</p><ul><li>mosn在接收dubbo请求，cpu卡点在streamConnection.Dispatch</li><li>mosn在转发dubbo请求，cpu卡点在downStream.Receive</li></ul><p>可以点击火焰图任意横条，进去查看长方块耗时和堆栈明细（请参考图1-2和1-3所示）：</p><p><img src="/images/1-2.png" alt="1-2"></p><center>图1-2 Dispatch火焰图明细</center><p><img src="/images/1-3.png" alt="1-3"></p><center>图1-3 Receive火焰图明细</center><h3 id="性能优化思路"><a href="#性能优化思路" class="headerlink" title="性能优化思路"></a>性能优化思路</h3><p>本文重点记录优化了哪些case才能提升50%+的吞吐量和降低rt，因此后面直接分析当前优化了哪些case。在此之前，我们以Dispatch为例，看下它为啥那么吃性能 。在terminal中通过以下命令可以查看代码行耗费cpu数据（代码有删减）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tool pprof mosnd pprof.mosn.samples.cpu<span class="number">.001</span>.pb.gz</span><br><span class="line">(pprof) list Dispatch</span><br><span class="line">Total: <span class="number">1.75</span>mins</span><br><span class="line">     <span class="number">370</span>ms     <span class="number">37.15s</span> (flat, cum) <span class="number">35.46</span>% of Total</span><br><span class="line">      <span class="number">10</span>ms       <span class="number">10</span>ms    <span class="number">123</span>:<span class="function"><span class="keyword">func</span> <span class="params">(conn *streamConnection)</span> <span class="title">Dispatch</span><span class="params">(buffer types.IoBuffer)</span></span> &#123;</span><br><span class="line">      <span class="number">40</span>ms      <span class="number">630</span>ms    <span class="number">125</span>:	log.DefaultLogger.Tracef(<span class="string">"stream connection dispatch data string = %v"</span>, buffer.String())</span><br><span class="line">         .          .    <span class="number">126</span>:</span><br><span class="line">         .          .    <span class="number">127</span>:	<span class="comment">// get sub protocol codec</span></span><br><span class="line">         .      <span class="number">250</span>ms    <span class="number">128</span>:	requestList := conn.codec.SplitFrame(buffer.Bytes())</span><br><span class="line">      <span class="number">20</span>ms       <span class="number">20</span>ms    <span class="number">129</span>:	<span class="keyword">for</span> _, request := <span class="keyword">range</span> requestList &#123;</span><br><span class="line">      <span class="number">10</span>ms      <span class="number">160</span>ms    <span class="number">134</span>:		headers := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">         .          .    <span class="number">135</span>:		<span class="comment">// support dynamic route</span></span><br><span class="line">      <span class="number">50</span>ms      <span class="number">920</span>ms    <span class="number">136</span>:		headers[strings.ToLower(protocol.MosnHeaderHostKey)] = conn.connection.RemoteAddr().String()</span><br><span class="line">         .          .    <span class="number">149</span>:</span><br><span class="line">         .          .    <span class="number">150</span>:		<span class="comment">// get stream id</span></span><br><span class="line">      <span class="number">10</span>ms      <span class="number">440</span>ms    <span class="number">151</span>:		streamID := conn.codec.GetStreamID(request)</span><br><span class="line">         .          .    <span class="number">156</span>:		<span class="comment">// request route</span></span><br><span class="line">         .       <span class="number">50</span>ms    <span class="number">157</span>:		requestRouteCodec, ok := conn.codec.(xprotocol.RequestRouting)</span><br><span class="line">         .          .    <span class="number">158</span>:		<span class="keyword">if</span> ok &#123;</span><br><span class="line">         .     <span class="number">20.11s</span>    <span class="number">159</span>:			routeHeaders := requestRouteCodec.GetMetas(request)</span><br><span class="line">         .          .    <span class="number">165</span>:		&#125;</span><br><span class="line">         .          .    <span class="number">166</span>:</span><br><span class="line">         .          .    <span class="number">167</span>:		<span class="comment">// tracing</span></span><br><span class="line">      <span class="number">10</span>ms       <span class="number">80</span>ms    <span class="number">168</span>:		tracingCodec, ok := conn.codec.(xprotocol.Tracing)</span><br><span class="line">         .          .    <span class="number">169</span>:		<span class="keyword">var</span> span types.Span</span><br><span class="line">         .          .    <span class="number">170</span>:		<span class="keyword">if</span> ok &#123;</span><br><span class="line">      <span class="number">10</span>ms      <span class="number">1.91s</span>    <span class="number">171</span>:			serviceName := tracingCodec.GetServiceName(request)</span><br><span class="line">         .      <span class="number">2.17s</span>    <span class="number">172</span>:			methodName := tracingCodec.GetMethodName(request)</span><br><span class="line">         .          .    <span class="number">176</span>:</span><br><span class="line">         .          .    <span class="number">177</span>:			<span class="keyword">if</span> trace.IsEnabled() &#123;</span><br><span class="line">         .       <span class="number">50</span>ms    <span class="number">179</span>:				tracer := trace.Tracer(protocol.Xprotocol)</span><br><span class="line">         .          .    <span class="number">180</span>:				<span class="keyword">if</span> tracer != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="number">20</span>ms      <span class="number">1.66s</span>    <span class="number">181</span>:					span = tracer.Start(conn.context, headers, time.Now())</span><br><span class="line">         .          .    <span class="number">182</span>:				&#125;</span><br><span class="line">         .          .    <span class="number">183</span>:			&#125;</span><br><span class="line">         .          .    <span class="number">184</span>:		&#125;</span><br><span class="line">         .          .    <span class="number">185</span>:</span><br><span class="line">         .      <span class="number">110</span>ms    <span class="number">186</span>:		reqBuf := networkbuffer.NewIoBufferBytes(request)</span><br><span class="line">         .          .    <span class="number">188</span>:		<span class="comment">// append sub protocol header</span></span><br><span class="line">      <span class="number">10</span>ms      <span class="number">950</span>ms    <span class="number">189</span>:		headers[types.HeaderXprotocolSubProtocol] = <span class="keyword">string</span>(conn.subProtocol)</span><br><span class="line">      <span class="number">10</span>ms      <span class="number">4.96s</span>    <span class="number">190</span>:		conn.OnReceive(ctx, streamID, protocol.CommonHeader(headers), reqBuf, span, isHearbeat)</span><br><span class="line">      <span class="number">30</span>ms       <span class="number">60</span>ms    <span class="number">191</span>:		buffer.Drain(requestLen)</span><br><span class="line">         .          .    <span class="number">192</span>:	&#125;</span><br><span class="line">         .          .    <span class="number">193</span>:&#125;</span><br></pre></td></tr></table></figure><p>通过上面 <code>list Dispatch</code> 命令，性能卡点主要分布在 <code>159</code> 、 <code>171</code> 、<code>172</code> 、 <code>181</code> 、和 <code>190</code> 等行，主要卡点在解码dubbo参数、重复解参数、tracer、发序列化和log等。</p><h4 id="1-优化dubbo解码GetMetas"><a href="#1-优化dubbo解码GetMetas" class="headerlink" title="1. 优化dubbo解码GetMetas"></a>1. 优化dubbo解码GetMetas</h4><p>我们通过解码dubbo的body可以获得以下信息，调用的目标接口(interface)和调用方法的服务分组(group)等信息，但是需要跳过所有业务方法参数，目前使用开源的hessian-go库，解析string和map性能较差, 提升hessian库解码性能，会在本文后面讲解。</p><p><strong>优化思路：</strong></p><p>在mosn的ingress端(mosn直接转发请求给本地java server进程), 我们根据请求的path和version去窥探用户使用的interface和group, 构建正确的dataId可以进行无脑转发，无需解码body，榨取性能提升。</p><p>我们可以在服务注册时，构建服务发布的path、version和group到interface、group映射。在mosn转发dubbo请求时可以通过读锁查cache+跳过解码body，加速mosn性能。</p><p>因此我们构建以下cache实现(数组+链表数据结构), 可参见<a href="https://github.com/mosn/mosn/pull/1174/commits/9020ee9995cd15a7a4321a375a9506cf94dc70a8#diff-f5ff30debd68b8318c8236a0b5ccde07R6" target="_blank" rel="noopener">优化代码diff</a> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// metadata.go</span></span><br><span class="line"><span class="comment">// DubboPubMetadata dubbo pub cache metadata</span></span><br><span class="line"><span class="keyword">var</span> DubboPubMetadata = &amp;Metadata&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DubboSubMetadata dubbo sub cache metadata</span></span><br><span class="line"><span class="keyword">var</span> DubboSubMetadata = &amp;Metadata&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Metadata cache service pub or sub metadata.</span></span><br><span class="line"><span class="comment">// speed up for decode or encode dubbo peformance.</span></span><br><span class="line"><span class="comment">// please do not use outside of the dubbo framwork.</span></span><br><span class="line"><span class="keyword">type</span> Metadata <span class="keyword">struct</span> &#123;</span><br><span class="line">	data <span class="keyword">map</span>[<span class="keyword">string</span>]*Node</span><br><span class="line">	mu   sync.RWMutex <span class="comment">// protect data internal</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find cached pub or sub metatada.</span></span><br><span class="line"><span class="comment">// caller should be check match is true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Metadata)</span> <span class="title">Find</span><span class="params">(path, version <span class="keyword">string</span>)</span> <span class="params">(node *Node, matched <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// we found nothing</span></span><br><span class="line">	<span class="keyword">if</span> m.data == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m.mu.RLocker().Lock()</span><br><span class="line">	<span class="comment">// for performance</span></span><br><span class="line">	<span class="comment">// m.mu.RLocker().Unlock() should be called.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// we check head node first</span></span><br><span class="line">	head := m.data[path]</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> || head.count &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		m.mu.RLocker().Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node = head.Next</span><br><span class="line">	<span class="comment">// just only once, just return</span></span><br><span class="line">	<span class="comment">// for dubbo framwork, that's what we're expected.</span></span><br><span class="line">	<span class="keyword">if</span> head.count == <span class="number">1</span> &#123;</span><br><span class="line">		m.mu.RLocker().Unlock()</span><br><span class="line">		<span class="keyword">return</span> node, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> found *Node</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ; node != <span class="literal">nil</span>; node = node.Next &#123;</span><br><span class="line">		<span class="keyword">if</span> node.Version == version &#123;</span><br><span class="line">			<span class="keyword">if</span> found == <span class="literal">nil</span> &#123;</span><br><span class="line">				found = node</span><br><span class="line">			&#125;</span><br><span class="line">			count++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m.mu.RLocker().Unlock()</span><br><span class="line">	<span class="keyword">return</span> found, count == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register pub or sub metadata</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Metadata)</span> <span class="title">Register</span><span class="params">(path <span class="keyword">string</span>, node *Node)</span></span> &#123;</span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="comment">// for performance</span></span><br><span class="line">	<span class="comment">// m.mu.Unlock() should be called.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> m.data == <span class="literal">nil</span> &#123;</span><br><span class="line">		m.data = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Node, <span class="number">4</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we check head node first</span></span><br><span class="line">	head := m.data[path]</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		head = &amp;Node&#123;</span><br><span class="line">			count: <span class="number">1</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// update head</span></span><br><span class="line">		m.data[path] = head</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	insert := &amp;Node&#123;</span><br><span class="line">		Service: node.Service,</span><br><span class="line">		Version: node.Version,</span><br><span class="line">		Group:   node.Group,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	next := head.Next</span><br><span class="line">	<span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// fist insert, just insert to head</span></span><br><span class="line">		head.Next = insert</span><br><span class="line">		<span class="comment">// record last element</span></span><br><span class="line">		head.last = insert</span><br><span class="line">		m.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we check already exist first</span></span><br><span class="line">	<span class="keyword">for</span> ; next != <span class="literal">nil</span>; next = next.Next &#123;</span><br><span class="line">		<span class="comment">// we found it</span></span><br><span class="line">		<span class="keyword">if</span> next.Version == node.Version &amp;&amp; next.Group == node.Group &#123;</span><br><span class="line">			<span class="comment">// release lock and no nothing</span></span><br><span class="line">			m.mu.Unlock()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	head.count++</span><br><span class="line">	<span class="comment">// append node to the end of the list</span></span><br><span class="line">	head.last.Next = insert</span><br><span class="line">	<span class="comment">// update last element</span></span><br><span class="line">	head.last = insert</span><br><span class="line">	m.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过服务注册时构建好的cache，可以在mosn的stream做解码时命中cache, 无需解码参数获取接口和group信息，可参见<a href="https://github.com/mosn/mosn/pull/1174/commits/9020ee9995cd15a7a4321a375a9506cf94dc70a8#diff-73d1153005841c788c91116915f460a5R188" target="_blank" rel="noopener">优化代码diff</a> :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decoder.go</span></span><br><span class="line"><span class="comment">// for better performance.</span></span><br><span class="line"><span class="comment">// If the ingress scenario is not using group,</span></span><br><span class="line"><span class="comment">// we can skip parsing attachment to improve performance</span></span><br><span class="line"><span class="keyword">if</span> listener == IngressDubbo &#123;</span><br><span class="line">	<span class="keyword">if</span> node, matched = DubboPubMetadata.Find(path, version); matched &#123;</span><br><span class="line">		meta[ServiceNameHeader] = node.Service</span><br><span class="line">		meta[GroupNameHeader] = node.Group</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> listener == EgressDubbo &#123;</span><br><span class="line">	<span class="comment">// for better performance.</span></span><br><span class="line">	<span class="comment">// If the egress scenario is not using group,</span></span><br><span class="line">	<span class="comment">// we can skip parsing attachment to improve performance</span></span><br><span class="line">	<span class="keyword">if</span> node, matched = DubboSubMetadata.Find(path, version); matched &#123;</span><br><span class="line">		meta[ServiceNameHeader] = node.Service</span><br><span class="line">		meta[GroupNameHeader] = node.Group</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mosn的egress端(mosn直接转发请求给本地java client进程), 我们采用类似的思路, 我们根据请求的path和version去窥探用户使用的interface和group, 构建正确的dataId可以进行无脑转发，无需解码body，榨取性能提升。</p><h4 id="2-优化dubbo解码参数"><a href="#2-优化dubbo解码参数" class="headerlink" title="2. 优化dubbo解码参数"></a>2. 优化dubbo解码参数</h4><p>在dubbo解码参数值的时候 ，mosn采用的是hessian的正则表达式查找，非常耗费性能。我们先看下优化前后benchmark对比, 性能提升50倍!!!</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test -bench=BenchmarkCountArgCount -run=^$ -benchmem</span><br><span class="line">BenchmarkCountArgCountByRegex<span class="number">-12</span>	<span class="number">200000</span>	<span class="number">6236</span> ns/op	<span class="number">1472</span> B/op	<span class="number">24</span> allocs/op</span><br><span class="line">BenchmarkCountArgCountOptimized<span class="number">-12</span>	<span class="number">10000000</span>	<span class="number">124</span> ns/op	<span class="number">0</span> B/op	<span class="number">0</span> allocs/op</span><br></pre></td></tr></table></figure><p><strong>优化思路：</strong></p><p>可以消除正则表达式，采用简单字符串解析识别参数类型个数， <a href="https://github.com/zonghaishang/dubbo/blob/e0fd702825a274379fb609229bdb06ca0586122e/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ReflectUtils.java#L370" target="_blank" rel="noopener">dubbo编码参数个数字符串实现</a> 并不复杂, 主要给对象加L前缀、数组加[、primitive类型有单字符代替。采用go可以实现同等解析, 可以参考<a href="https://github.com/mosn/mosn/pull/1174/commits/9020ee9995cd15a7a4321a375a9506cf94dc70a8#diff-73d1153005841c788c91116915f460a5R245" target="_blank" rel="noopener">优化代码diff</a> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getArgumentCount</span><span class="params">(desc <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(desc)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> args, next = <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> desc &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// is array ?</span></span><br><span class="line">		<span class="keyword">if</span> ch == <span class="string">'['</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// is object ?</span></span><br><span class="line">		<span class="keyword">if</span> next &amp;&amp; ch != <span class="string">';'</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> ch &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'V'</span>, <span class="comment">// void</span></span><br><span class="line">			<span class="string">'Z'</span>, <span class="comment">// boolean</span></span><br><span class="line">			<span class="string">'B'</span>, <span class="comment">// byte</span></span><br><span class="line">			<span class="string">'C'</span>, <span class="comment">// char</span></span><br><span class="line">			<span class="string">'D'</span>, <span class="comment">// double</span></span><br><span class="line">			<span class="string">'F'</span>, <span class="comment">// float</span></span><br><span class="line">			<span class="string">'I'</span>, <span class="comment">// int</span></span><br><span class="line">			<span class="string">'J'</span>, <span class="comment">// long</span></span><br><span class="line">			<span class="string">'S'</span>: <span class="comment">// short</span></span><br><span class="line">			args++</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// we found object</span></span><br><span class="line">			<span class="keyword">if</span> ch == <span class="string">'L'</span> &#123;</span><br><span class="line">				args++</span><br><span class="line">				next = <span class="literal">true</span></span><br><span class="line">				<span class="comment">// end of object ?</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ch == <span class="string">';'</span> &#123;</span><br><span class="line">				next = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-优化hessian-go解码string性能"><a href="#3-优化hessian-go解码string性能" class="headerlink" title="3. 优化hessian go解码string性能"></a>3. 优化hessian go解码string性能</h4><p>在图1-2中可以看到hessian go在解码string占比cpu采样较高，我们在解码dubbo请求时，会解析dubbo框架版本、调用path、接口版本和方法名，这些都是string类型，hessian go解析string会影响rpc性能。</p><p>我们首先跑一下benchmark前后解码string性能对比，性能提升56.11%!!! 对应到rpc中有5%左右提升。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkDecodeStringOriginal-12     1967202     613 ns/op     272 B/op     6 allocs/op</span><br><span class="line">BenchmarkDecodeStringOptimized-12     4477216     269 ns/op     224 B/op     5 allocs/op</span><br></pre></td></tr></table></figure><p><strong>优化思路：</strong></p><p>直接使用utf-8 byte解码，性能最高，之前先解码byte成rune, 对rune解码成string，及其耗费性能。增加批量string chunk copy, 降低read调用，并且使用unsafe转换string(避免一些校验)，因为代码优化diff较多，这里给出<a href="https://github.com/apache/dubbo-go-hessian2/pull/188" target="_blank" rel="noopener">优化代码pr</a> 。</p><p>go sdk代码<code>runtime/string.go#slicerunetostring</code>(rune转换成string)， 同样是把rune转成byte数组，这里给了我优化思路启发。</p><h4 id="4-优化hessian库编解码对象"><a href="#4-优化hessian库编解码对象" class="headerlink" title="4. 优化hessian库编解码对象"></a>4. 优化hessian库编解码对象</h4><p>虽然消除了dubbo的body解码部分，但是mosn在处理dubbo请求时，必须要借助hessian去decode请求头部的框架版本、请求path和接口版本值。但是每次在解码的时候都会创建序列化对象，开销非常高，因为hessian每次在创建reader的时候会allocate 4k数据并reset。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      10ms       10ms     75:func unSerialize(serializeId int, data []byte, parseCtl unserializeCtl) *dubboAttr &#123;</span><br><span class="line">      10ms      140ms     82:	attr := &amp;dubboAttr&#123;&#125;</span><br><span class="line">      80ms      2.56s     83:	decoder := hessian.NewDecoderWithSkip(data[:])</span><br><span class="line">ROUTINE ======================== bufio.NewReaderSize in /usr/local/go/src/bufio/bufio.go</span><br><span class="line">      50ms      2.44s (flat, cum)  2.33% of Total</span><br><span class="line">         .      220ms     55:	r := new(Reader)</span><br><span class="line">      50ms      2.22s     56:	r.reset(make([]byte, size), rd)</span><br><span class="line">         .          .     57:	return r</span><br><span class="line">         .          .     58:&#125;</span><br></pre></td></tr></table></figure><p>我们可以写个池化内存前后性能对比, 性能提升85.4%!!! , <a href="https://github.com/zonghaishang/dubbo-go-hessian2/blob/9b418c4e2700964f244e6b982855b4e89b45990d/string_test.go#L161" target="_blank" rel="noopener">benchmark用例</a> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkNewDecoder<span class="number">-12</span>	<span class="number">1487685</span>	<span class="number">803</span> ns/op	<span class="number">4528</span> B/op	<span class="number">9</span> allocs/op</span><br><span class="line">BenchmarkNewDecoderOptimized<span class="number">-12</span>	<span class="number">10564024</span>	<span class="number">117</span> ns/op	<span class="number">128</span> B/op	<span class="number">3</span> allocs/op</span><br></pre></td></tr></table></figure><p><strong>优化思路：</strong></p><p>在每次编解码时，池化hessian的decoder对象，新增NewCheapDecoderWithSkip并支持reset复用decoder。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var decodePool = &amp;sync.Pool&#123;</span><br><span class="line">    New: func() interface&#123;&#125; &#123;</span><br><span class="line">        return hessian.NewCheapDecoderWithSkip([]byte&#123;&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在解码时按照如下方法调用</span><br><span class="line">decoder := decodePool.Get().(*hessian.Decoder)</span><br><span class="line">// fill decode data</span><br><span class="line">decoder.Reset(data[:])</span><br><span class="line">hessianPool.Put(decoder)</span><br></pre></td></tr></table></figure><h4 id="5-优化重复解码service和methodName值"><a href="#5-优化重复解码service和methodName值" class="headerlink" title="5. 优化重复解码service和methodName值"></a>5. 优化重复解码service和methodName值</h4><p>xprotocol在实现xprotocol.Tracing获取服务名称和方法时，会触发调用并解析2次，调用开销比较大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10ms      1.91s    171:			serviceName := tracingCodec.GetServiceName(request)</span><br><span class="line">   .      2.17s    172:			methodName := tracingCodec.GetMethodName(request)</span><br></pre></td></tr></table></figure><p><strong>优化思路：</strong></p><p>因为在GetMetas里面已经解析过一次了，可以把解析过的headers传进去，如果headers有了就不用再去解析了，并且重构接口名称为一个，返回值为二元组，消除一次调用。</p><h4 id="6-优化streamId类型转换"><a href="#6-优化streamId类型转换" class="headerlink" title="6. 优化streamId类型转换"></a>6. 优化streamId类型转换</h4><p>在go中将byte数组和streamId进行互转的时候，比较费性能。</p><p><strong>优化思路：</strong></p><p>生产代码中, 尽量不要使用fmt.Sprintf和fmt.Printf去做类型转换和打印信息。可以使用strconv去转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   .      430ms    147: reqIDStr := fmt.Sprintf(&quot;%d&quot;, reqID)</span><br><span class="line">60ms      4.10s    168: fmt.Printf(&quot;src=%s, len=%d, reqid:%v\n&quot;, streamID, reqIDStrLen, reqIDStr)</span><br></pre></td></tr></table></figure><h4 id="7-优化昂贵的系统调用"><a href="#7-优化昂贵的系统调用" class="headerlink" title="7. 优化昂贵的系统调用"></a>7. 优化昂贵的系统调用</h4><p>mosn在解码dubbo的请求时，会在header中塞一份远程host的地址，并且在for循环中获取remoteIp，系统调用开销比较高。</p><p><strong>优化思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50ms      920ms    136:		headers[strings.ToLower(protocol.MosnHeaderHostKey)] = conn.connection.RemoteAddr().String()</span><br></pre></td></tr></table></figure><p>在获取远程地址时，尽可能在streamConnection中cache远程ip值，不要每次都去调用RemoteAddr。</p><h4 id="8-优化slice和map触发扩容和rehash"><a href="#8-优化slice和map触发扩容和rehash" class="headerlink" title="8. 优化slice和map触发扩容和rehash"></a>8. 优化slice和map触发扩容和rehash</h4><p>在mosn处理dubbo请求时，会根据接口、版本和分组去构建dataId，然后匹配cluster, 会创建默认slice和map对象，经过性能诊断，导致不断allocate slice和grow map容量比较费性能。</p><p><strong>优化思路：</strong></p><p>使用slice和map时，尽可能预估容量大小，使用make(type, capacity)去指定初始大小。</p><h4 id="9-优化trace日志级别输出"><a href="#9-优化trace日志级别输出" class="headerlink" title="9. 优化trace日志级别输出"></a>9. 优化trace日志级别输出</h4><p>mosn中不少代码在处理逻辑时，会打很多trace级别的日志，并且会传递不少参数值。</p><p><strong>优化思路：</strong></p><p>调用trace输出前，尽量判断一下日志级别，如果有多个trace调用，尽可能把所有字符串写到buf中，然后把buf内容写到日志中，并且尽可能少的调用trace日志方法。</p><h4 id="10-优化tracer、log和metrics"><a href="#10-优化tracer、log和metrics" class="headerlink" title="10. 优化tracer、log和metrics"></a>10. 优化tracer、log和metrics</h4><p>在大促期间，对机器的性能要求较高，经过性能诊断，tracer、mosn log和cloud metrics写日志(io操作)非常耗费性能。</p><p><strong>优化思路：</strong></p><p>通过配置中心下发配置或者增加大促开关，允许api调用这些feature的开关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/api/v1/downgrade/on</span><br><span class="line">/api/v1/downgrade/off</span><br></pre></td></tr></table></figure><h4 id="11-优化route-header解析"><a href="#11-优化route-header解析" class="headerlink" title="11. 优化route header解析"></a>11. 优化route header解析</h4><p>mosn中在做路由前，需要做大量的header的map访问，比如ldc、antvip等逻辑判断，商业版或者开源mosn不需要这些逻辑，这些也会占用一些开销。</p><p><strong>优化思路：</strong></p><p>如果是云上逻辑，主站的逻辑都不走。</p><h4 id="12-优化featuregate调用"><a href="#12-优化featuregate调用" class="headerlink" title="12.  优化featuregate调用"></a>12. 优化featuregate调用</h4><p>在mosn中处理请求时，为了区分主站和商业版路由逻辑，会通过featuregate判断逻辑走哪部分。通过featuregate调用开销较大，需要频繁的做类型转换和多层map去获取。</p><p><strong>优化思路：</strong></p><p>通过一个bool变量记录featuregate对应开关，如果没有初始化过，就主动调用一下featuregate。</p><h3 id="未来性能优化思考"><a href="#未来性能优化思考" class="headerlink" title="未来性能优化思考"></a>未来性能优化思考</h3><p>经过几轮性能优化 ，目前看火焰图，卡点都在connection的read和write，可以优化的空间比较小了。但是可能从以下场景中获得收益：</p><ul><li>减少connection的read和write次数(syscall)</li><li>优化io线程模型，减少携程和上下文切换等</li></ul><p>作为结束，给出了最终优化后的火焰图 ，大部分卡点都在系统调用和网络读写, 请参考图1-4。</p><p><img src="/images/1-4.png" alt="mosn优化后火焰图"></p><center>图1-4 优化版本mosn+dubbo火线图</center><h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><p>花名诣极，开源Apache Dubbo PMC。目前就职于蚂蚁金服中间件团队，主攻rpc和Service mesh方向。 ‘’深入理解Apache Dubbo与实战’’图书作者。github: <a href="https://github.com/zonghaishang" target="_blank" rel="noopener">https://github.com/zonghaishang</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>pprof工具异常强大，可以诊断cpu、memory、go协程、tracer和死锁等，该工具可以参考<a href="https://blog.golang.org/pprof" target="_blank" rel="noopener">godoc</a>，性能优化参考：</p><ul><li><p><a href="https://blog.golang.org/pprof" target="_blank" rel="noopener">https://blog.golang.org/pprof</a></p></li><li><p><a href="https://www.cnblogs.com/Dr-wei/p/11742414.html" target="_blank" rel="noopener">https://www.cnblogs.com/Dr-wei/p/11742414.html</a></p></li><li><p><a href="https://www.youtube.com/watch?v=N3PWzBeLX2M" target="_blank" rel="noopener">https://www.youtube.com/watch?v=N3PWzBeLX2M</a></p></li></ul><div class="post-announce">感谢您的阅读，本文由 <a href="https://zonghaishang.github.io">诣极的博客</a> 版权所有。如若转载，请注明出处：诣极的博客（<a href="https://zonghaishang.github.io/2020/06/02/记一次对mosn中dubbo、hessian-go的性能优化/">https://zonghaishang.github.io/2020/06/02/记一次对mosn中dubbo、hessian-go的性能优化/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/10/26/Ubuntu18.0.4.1编译openjdk8/" title="Ubuntu18.0.4.1编译openjdk8"><i class="iconfont icon-prev"></i>Ubuntu18.0.4.1编译openjdk8</a></div><div class="post__prev post__prev--right"></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">花名诣极，开源Apache Dubbo PMC。曾就职于阿里巴巴集团、有赞科技，担任dubbo框架技术负责人。目前就职于蚂蚁金服中间件团队，主攻rpc和Service mesh方向。 ''深入理解Apache Dubbo与实战''图书作者。</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/工作经历/">工作经历</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/mosn/">mosn</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/jvm/">jvm</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/asm/">asm</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/arthas/">arthas</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Spring杂谈/">Spring杂谈</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Fastjson源码解析/">Fastjson源码解析</a><span class="block-list-count">11</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2020/06/02/记一次对mosn中dubbo、hessian-go的性能优化/" title="记一次对mosn中dubbo、hessian-go的性能优化"><div class="item__cover"><img src="/images/go.jpg" alt="记一次对mosn中dubbo、hessian-go的性能优化"></div><div class="item__info"><h3 class="item__title">记一次对mosn中dubbo、hessian-go的性能优化</h3><span class="item__text">2020-06-02</span></div></a></li><li class="latest-post-item"><a href="/2018/10/26/Ubuntu18.0.4.1编译openjdk8/" title="Ubuntu18.0.4.1编译openjdk8"><div class="item__cover"><img src="/images/jdk.jpg" alt="Ubuntu18.0.4.1编译openjdk8"></div><div class="item__info"><h3 class="item__title">Ubuntu18.0.4.1编译openjdk8</h3><span class="item__text">2018-10-26</span></div></a></li><li class="latest-post-item"><a href="/2018/10/26/理解arthas原理/" title="理解arthas原理"><div class="item__cover"><img src="/images/arthas.png" alt="理解arthas原理"></div><div class="item__info"><h3 class="item__title">理解arthas原理</h3><span class="item__text">2018-10-26</span></div></a></li><li class="latest-post-item"><a href="/2018/10/22/理解字节码原理/" title="理解Java字节码原理"><div class="item__cover"><img src="/images/asm.png" alt="理解Java字节码原理"></div><div class="item__info"><h3 class="item__title">理解Java字节码原理</h3><span class="item__text">2018-10-22</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Dubbo框架问题/">Dubbo框架问题</a></li><li class="tag-item"><a class="tag-link" href="/tags/Fastjson源码解析/">Fastjson源码解析</a></li><li class="tag-item"><a class="tag-link" href="/tags/Spring杂谈/">Spring杂谈</a></li><li class="tag-item"><a class="tag-link" href="/tags/arthas/">arthas</a></li><li class="tag-item"><a class="tag-link" href="/tags/asm/">asm</a></li><li class="tag-item"><a class="tag-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-item"><a class="tag-link" href="/tags/go/">go</a></li><li class="tag-item"><a class="tag-link" href="/tags/jvm/">jvm</a></li><li class="tag-item"><a class="tag-link" href="/tags/jvm-openjdk/">jvm, openjdk</a></li><li class="tag-item"><a class="tag-link" href="/tags/mosn/">mosn</a></li><li class="tag-item"><a class="tag-link" href="/tags/openjdk/">openjdk</a></li><li class="tag-item"><a class="tag-link" href="/tags/工作经历/">工作经历</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">诣极的博客，主要用于分享日常学习和工作的一些心得总结。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Hangzhou, Zhejiang Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>yiji@apache.org</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/images/jmj.png" alt="logo" title="诣极的博客"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="" target="_blank">Blog</a> 2018 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/zonghaishang" target="_blank">诣极</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/zonghaishang" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:yiji@apache.org" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="https://zonghaishang.github.io/" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>