<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>理解Java字节码原理 | 诣极的博客</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="incubator-dubbo, dubbo, 后端开发, 全栈开发, javascript, java"><meta name="description" content="商宗海，花名诣极，开源dubbo核心开发者之一。曾就职于阿里巴巴、金蝶中国。现就职于有赞科技，担任dubbo框架技术负责人，参与中间件开发，长期活跃在dubbo社区。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://zonghaishang.github.io/2018/10/22/理解字节码原理/index.html"><link rel="icon" type="image/png" href="null" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="诣极的博客"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(null)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="诣极的博客" alt="诣极的博客"><img src="/images/yiji.png" alt="诣极的博客"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/tags" alt="标签" title="标签">标签</a></li><li class="nav__item"><a href="/categories" alt="类别" title="类别">类别</a></li><li class="nav__item"><a href="https://github.com/zonghaishang" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/images/asm.png" alt="理解Java字节码原理"></div><header class="post__info"><h1 class="post__title">理解Java字节码原理</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://github.com/zonghaishang">诣极</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-10-22</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/jvm/">Jvm</a></li><li class="mark__item"><a href="/tags/arthas/">Arthas</a></li><li class="mark__item"><a href="/tags/asm/">Asm</a></li></ul></div></div></header><div class="post__content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>为什么要学习字节码技术？无论是Java程序员还是架构师，在我们平常使用的中间件，dubbo、fastjson和arthas等框架或者组件时，我们已经在接触字节码技术了，更重要的是，Java字节码恰恰是JVM的基础。</p><p>什么是字节码？Java字节码是Java代码（即类文件）的中间表示，它在JVM中执行, 没有Java字节码就无法运行整个Java开发生态系统，特别是如何处理和定义Java开发人员正在编写的代码。</p><p>通过本章的分析，主要涵盖以下几个内容：</p><ul><li>获取字节码</li><li>读取字节码</li><li>字节码处理：局部变量，指令跳转，方法调用</li><li>字节码在arthas中的使用</li><li>ASM学习</li></ul><p>让我们正式开始学习字节码技术吧！</p><h2 id="字节码简要介绍"><a href="#字节码简要介绍" class="headerlink" title="字节码简要介绍"></a>字节码简要介绍</h2><p>Java字节码是JVM执行的指令形式。通常，Java程序员不需要知道Java字节码的工作原理。但是，了解平台的低级细节是什么让你成为一个更好的程序员, 我也是其中一员 :-)</p><p>理解字节码对于工具和程序分析领域至关重要，应用程序可以修改字节码以根据应用程序的需求调整行为。分析器，模拟框架，AOP - 要创建这些工具，开发人员必须彻底了解Java字节码。</p><h3 id="先看一个简单的例子"><a href="#先看一个简单的例子" class="headerlink" title="先看一个简单的例子"></a>先看一个简单的例子</h3><p>在开始字节码之前，我们先看一个<code>1 + 1</code>的问题，因为栈很容易评估反向表达式<code>1 1 +</code>，所以可以先把2个1压入堆栈，然后执行加法操作：</p><p><img src="https://zonghaishang.github.io/images/1540196728576.png" class="pretty"></p><p>Java字节码的计算模型是面向堆栈的模型。上面的例子用Java字节码指令表示是相同的，唯一的区别是操作码附加了一些特定的语义：</p><p><img src="https://zonghaishang.github.io/images/1540197154845.png" class="pretty"></p><p>操作码iconst_1将常量1放入堆栈。指令iadd对两个整数执行加法运算，并将结果保留在堆栈的顶部。</p><p>字节码是单字节指令组成，因此有256种可能的操作码。实际指令使用大约200个操作码，其中一些操作码保留用于调试器操作。</p><p>根据指令的性质，我们可以将这些分组分为几个类别：</p><ul><li>堆栈操作指令，包括与局部变量的交互。</li><li>控制流程</li><li>对象操作，包括 方法调用</li><li>算术和类型转换</li></ul><h3 id="javap反编译代码"><a href="#javap反编译代码" class="headerlink" title="javap反编译代码"></a>javap反编译代码</h3><p>要获取反编译后的字节码，我们只需要对<code>.class</code>文件执行<code>javap -c</code>命令即可，作为演示开始编写源代码并编译，我们将从这个类开始，该类将作为我们的示例应用程序的入口点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yiji@apache.org</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译类文件后，要获取上述示例的字节码列表，需要执行以下命令：<code>javap -c HelloWorld</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"HelloWorld.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #3                  // String Hello world!</span><br><span class="line">       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数的主体应该是空的，为什么仍然会生成一些指令？每个构造函数都会调用super()，编译器在背后帮我做的这件事情。</p><p>您可能已经注意到指令指后面＃1，＃2，＃3的某些编号参数，这是对常量池的引用。如何才能找出常量是什么以及如何在列表中看到常量池？我们可以在反汇编类时将<code>-verbose</code>参数应用于<code>javap</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#15         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #18            // Hello world!</span><br><span class="line">   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #21            // HelloWorld</span><br><span class="line">   #6 = Class              #22            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #15 = NameAndType       #7:#8          // "&lt;init&gt;":()V</span><br></pre></td></tr></table></figure><p>在反编译结果中包含有关类文件的大量技术信息：版本，MD5校验和，访问修饰符和常量池等。</p><p>我们还可以看到那里的访问控制标志：ACC_PUBLIC和ACC_SUPER。该ACC_PUBLIC标志通俗易懂。但是是ACC_SUPER代表什么意思？ACC_SUPER纠正invokespecial指令调用超级方法的问题。可以将其视为Java 1.0的错误修复，以便它可以正确地发现超类方法。从Java 1.1开始，编译器总是ACC_SUPER为字节码生成访问者标志。</p><p>可以在常量池中找到表示的常量定义：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#1 = Methodref          #6.#15         // java/lang/Object."&lt;init&gt;":()V</span><br></pre></td></tr></table></figure><p>常量定义是可组合的，这意味着常量可以由从同一个常量池引用的其他常量组成。当使用<code>javap -verbose</code>参数时，还有一些其他的东西可以揭示出来。例如，有关方法的更多信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String Hello world!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure><p>访问器标志也是为方法生成的，我们也可以看到执行该方法需要多深的堆栈，它需要多少参数，以及需要在局部变量表中保留多少局部变量槽。</p><h3 id="理解JVM字节码执行模型"><a href="#理解JVM字节码执行模型" class="headerlink" title="理解JVM字节码执行模型"></a>理解JVM字节码执行模型</h3><p>要理解字节码的细节，我们需要了解字节码的执行模型。JVM是基于堆栈的模型执行，每个线程都有一个存储帧的JVM堆栈。每次调用方法时都会创建一个栈帧。一个栈帧由一个操作数堆栈、一个局部变量数组和一个对当前方法类的运行时常量池的引用组成。我们在最初的例子中看到了所有这些信息。</p><p><img src="https://zonghaishang.github.io/images/1540203209160.png" class="pretty"></p><blockquote><p>局部变量表</p><blockquote><p>包含方法的参数，还用于保存局部变量的值。局部变量数组的大小在编译时确定，并且取决于局部变量和方法参数的数量和大小。</p></blockquote></blockquote><blockquote><p>操作数堆栈</p><blockquote><p>用于推送和弹出值的后进先出(LIFO)堆栈, 它的大小也在编译时确定。某些操作码指令将值推送到操作数栈; 其他一些操作指令，从操作数栈中获取操作数，并保存在局部变量表中。操作数堆栈还用于从方法接收返回值。</p></blockquote></blockquote><p>在调试过程中我们可以丢弃当前方法栈帧回到上次方法调用：</p><p><img src="https://zonghaishang.github.io/images/1540207525392.png" class="pretty"></p><p>每条指令都有自己的十六进制表示：</p><p><img src="https://zonghaishang.github.io/images/1540209698096.png" class="pretty"></p><p>下面是指令替换成字节码十六进制的标识：</p><p><img src="https://zonghaishang.github.io/images/1540210069875.png" class="pretty"></p><h3 id="更多的字节码指令展示"><a href="#更多的字节码指令展示" class="headerlink" title="更多的字节码指令展示"></a>更多的字节码指令展示</h3><p>前面已经提到了与堆栈一起使用的基本指令：将值推送到堆栈或从堆栈中获取值。但还有更多， 交换指令可以交换堆栈顶部的两个值。</p><p>下面是一些处理堆栈周围值的指令，首先是一些基本指令：dup和pop。dup指令复制堆栈顶部的值，pop指令从堆栈顶部弹出数据。</p><p>还有一些更复杂的指令：例如swap，dup_x1和dup2_x1。交换指令在堆栈顶部交换两个值，例如A和B交换位置; dup_x1将顶部值的副本从顶部插入堆栈中的第3个值; dup2_x1复制两个顶部值并插入第3个值之后。下面的例子详细描述每条指令执行的状态。</p><p><img src="https://zonghaishang.github.io/images/1540211921006.png" class="pretty"></p><p>dup_x1和dup2_x1指令似乎有点绕，为什么需要这样的行为，举个实际的例子，如何交换双重类型的2个值？</p><p>double在堆栈中占用两个插槽，这意味着如果我们在堆栈上有两个double值，它们将占用四个插槽。要交换两个double值，我们想使用swap指令，但问题是它只适用于单字指令。</p><p>解决方法是使用dup2_x2复制顶部双精度值的指令，然后我们可以使用pop2指令弹出顶部值。</p><p><img src="https://zonghaishang.github.io/images/1540212418154.png" class="pretty"></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>当堆栈执行时，局部变量表用于保存中间结果并与堆栈直接交互。现在我们添加一下代码进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yiji@apache.org</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Average average = <span class="keyword">new</span> Average();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        average.execute(n1);</span><br><span class="line">        average.execute(n2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> avg = average.getAverage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过类<code>Average</code>计算数字的平均值，每次执行<code>average.execute(...)</code>会进行计算。通过反编译代码得到字节码指令如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">6</span>, args_size=<span class="number">1</span></span><br><span class="line">       0: new           #2                  // class Average</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: invokespecial #3                  // Method Average."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: iconst_1</span><br><span class="line">       <span class="number">9</span>: istore_2</span><br><span class="line">      <span class="number">10</span>: iconst_2</span><br><span class="line">      <span class="number">11</span>: istore_3</span><br><span class="line">      <span class="number">12</span>: aload_1</span><br><span class="line">      <span class="number">13</span>: iload_2</span><br><span class="line">      14: invokevirtual #4                  // Method Average.execute:(I)V</span><br><span class="line">      <span class="number">17</span>: aload_1</span><br><span class="line">      <span class="number">18</span>: iload_3</span><br><span class="line">      19: invokevirtual #4                  // Method Average.execute:(I)V</span><br><span class="line">      <span class="number">22</span>: aload_1</span><br><span class="line">      23: invokevirtual #5                  // Method Average.getAverage:()D</span><br><span class="line">      <span class="number">26</span>: dstore        <span class="number">4</span></span><br><span class="line">      <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">9</span>: <span class="number">8</span></span><br><span class="line">      line <span class="number">10</span>: <span class="number">10</span></span><br><span class="line">      line <span class="number">12</span>: <span class="number">12</span></span><br><span class="line">      line <span class="number">13</span>: <span class="number">17</span></span><br><span class="line">      line <span class="number">15</span>: <span class="number">22</span></span><br><span class="line">      line <span class="number">16</span>: <span class="number">28</span></span><br><span class="line">   LocalVariableTable:</span><br><span class="line">    Start  Length  Slot  Name   Signature</span><br><span class="line">        <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">        <span class="number">8</span>      <span class="number">21</span>     <span class="number">1</span> average   LAverage;</span><br><span class="line">       <span class="number">10</span>      <span class="number">19</span>     <span class="number">2</span>    n1   I</span><br><span class="line">       <span class="number">12</span>      <span class="number">17</span>     <span class="number">3</span>    n2   I</span><br><span class="line">       <span class="number">28</span>       <span class="number">1</span>     <span class="number">4</span>   avg   D</span><br></pre></td></tr></table></figure><p>字节码偏移量<code>0</code>,<code>3</code>,<code>4</code>主要用于创建<code>Average</code>对象并初始化，<code>new</code>会创建类型对象标识符引用并压入操作数栈顶，<code>dup</code>会复制栈顶元素副本，<code>invokespecial</code>会调用对象初始化方法<code>&lt;init&gt;</code>，对象会从栈顶弹出。</p><p><code>7: astore_1</code> 会将操作数栈顶元素弹出存放在局部变量表第一个元素，也就是<code>average</code>。</p><p><code>iconst_1</code>和<code>iconst_2</code>将常量1和2加载到操作数栈，LocalVariableTable并通过指令istore_2和istore_3分别将它们存储在插槽2和3中，这里分别对应到<code>n1</code>和<code>n2</code>。</p><p>需要注意调用类似存储的指令实际上会从操作数栈顶部删除值。为了再次使用变量值，我们必须将其加载回堆栈。例如，在上面的字节码列表中，在调用<code>execute</code>方法之前，我们必须再次将参数的值加载到堆栈：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>: aload_1</span><br><span class="line"><span class="number">13</span>: iload_2</span><br><span class="line">14: invokevirtual #4                  // Method Average.execute:(I)V</span><br></pre></td></tr></table></figure><p>在调用<code>getAverage()</code>方法之后，执行结果会存储到操作数栈顶并再次将其存储到局部变量，<code>avg</code>变量的类型为double，所以使用<code>dstore</code>指令将结果写会到第4个局部变量中。</p><p>值得注意的事情局部变量表第一个插槽被方法的参数占用（静态方法）。在我们当前的示例中，它是静态方法，并且没有将此引用(this)分配给表中的插槽0。但是，对于非静态方法，这将分配给插槽0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果看不到反编译局部变量，可以用javac -g 指令生成调试信息，在用javap -c -l 就会生效。</span><br></pre></td></tr></table></figure><h3 id="指令跳转"><a href="#指令跳转" class="headerlink" title="指令跳转"></a>指令跳转</h3><p>跳转指令用于根据条件判定执行流程。比如<code>If-else</code>，三元运算符，各种循环甚至异常处理操作码都属于Java字节码的跳转控制。现在开始跳转指令分析，先添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yiji@apache.org</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Average average = <span class="keyword">new</span> Average();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> number : numbers) &#123;</span><br><span class="line">            average.execute(number);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，先执行<code>javac -g HelloWorld</code>， 然后反编译执行<code>javap -c -l HelloWorld</code>得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  Code:</span><br><span class="line">     0: new           #2                  // class Average</span><br><span class="line">     <span class="number">3</span>: dup</span><br><span class="line">     4: invokespecial #3                  // Method Average."&lt;init&gt;":()V</span><br><span class="line">     <span class="number">7</span>: astore_1</span><br><span class="line">     8: getstatic     #4                  // Field numbers:[I</span><br><span class="line">    <span class="number">11</span>: astore_2</span><br><span class="line">    <span class="number">12</span>: aload_2</span><br><span class="line">    <span class="number">13</span>: arraylength</span><br><span class="line">    <span class="number">14</span>: istore_3</span><br><span class="line">    <span class="number">15</span>: iconst_0</span><br><span class="line">    <span class="number">16</span>: istore        <span class="number">4</span></span><br><span class="line">    <span class="number">18</span>: iload         <span class="number">4</span></span><br><span class="line">    <span class="number">20</span>: iload_3</span><br><span class="line">    <span class="number">21</span>: if_icmpge     <span class="number">42</span></span><br><span class="line">    <span class="number">24</span>: aload_2</span><br><span class="line">    <span class="number">25</span>: iload         <span class="number">4</span></span><br><span class="line">    <span class="number">27</span>: iaload</span><br><span class="line">    <span class="number">28</span>: istore        <span class="number">5</span></span><br><span class="line">    <span class="number">30</span>: aload_1</span><br><span class="line">    <span class="number">31</span>: iload         <span class="number">5</span></span><br><span class="line">    33: invokevirtual #5                  // Method Average.execute:(I)V</span><br><span class="line">    <span class="number">36</span>: iinc          <span class="number">4</span>, <span class="number">1</span></span><br><span class="line">    <span class="number">39</span>: goto          <span class="number">18</span></span><br><span class="line">    <span class="number">42</span>: <span class="keyword">return</span></span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">14</span>: <span class="number">8</span></span><br><span class="line">    line <span class="number">15</span>: <span class="number">30</span></span><br><span class="line">    line <span class="number">14</span>: <span class="number">36</span></span><br><span class="line">    line <span class="number">18</span>: <span class="number">42</span></span><br><span class="line">  LocalVariableTable:</span><br><span class="line">    Start  Length  Slot  Name   Signature</span><br><span class="line">       <span class="number">30</span>       <span class="number">6</span>     <span class="number">5</span> number   I</span><br><span class="line">        -         -     <span class="number">4</span> $index</span><br><span class="line">        -         -     <span class="number">3</span> $length</span><br><span class="line">        -         -     <span class="number">2</span> $array</span><br><span class="line">        <span class="number">0</span>      <span class="number">43</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">        <span class="number">8</span>      <span class="number">35</span>     <span class="number">1</span> average   LAverage;</span><br></pre></td></tr></table></figure><p>字节码位置<code>8</code>到<code>16</code>的指令用于组织循环控制。你可以看到有三个变量，源代码中不会显示：<code>$array</code>，<code>$length</code>，<code>$index</code>-这些都是循环变量。该变量<code>$array</code>存储数组引用，<code>$length</code>使用该<code>arraylength</code>指令从该字段导出循环的长度。循环计数器<code>$index</code>在每次迭代后使用<code>iinc</code>指令递增。</p><p>这几个局部变量是分别通过字节码指令推演出来的，<code>11: astore_2</code> 会将操作数栈顶存到局部变量表<code>2</code>的位置，此时的栈顶是数组。<code>13: arraylength</code> 对数组长度计算放到栈顶，<code>14: istore_3</code>会将栈顶存放到局部变量<code>3</code>的位置。<code>15: iconst_0</code>和<code>16: istore 4</code>将数组索引存储到局部变量表<code>4</code>的位置。</p><p>循环体的第一条指令用于执行循环计数器与数组长度的比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18: iload         4</span><br><span class="line">20: iload_3</span><br><span class="line">21: if_icmpge     42</span><br></pre></td></tr></table></figure><p><code>if_icmpge</code>指令会比较操作数栈顶部2个元素。该if_ icmpge指令的意思是，如果一个值大于等于其他值，跳转到紧跟的字节码偏移，如果$index大于或等于$length，则执行应标有43位置的字节码指令(直接返回)，如果条件不成立，然后循环继续下一次迭代(执行<code>if_icmpge</code>下一行指令)。</p><p>在执行完获取数组值，然后调用方法<code>execute</code>之后，会执行如下跳转指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">36</span>: iinc          <span class="number">4</span>, <span class="number">1</span></span><br><span class="line"><span class="number">39</span>: goto          <span class="number">18</span></span><br></pre></td></tr></table></figure><p><code>iinc</code>会对第<code>4</code>个局部变量执行自增1，然后<code>goto</code>指令跳转到字节偏移<code>18</code>的位置开始下一次循环。</p><h3 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h3><p>Java中有一个关键字<code>new</code>，也有一个名为<code>new</code>的字节码指令。当我们创建<code>Average</code>类的实例时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Average average = <span class="keyword">new</span> Average();</span><br></pre></td></tr></table></figure><p>编译器会帮我生成一系列字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0: new           #2                  // class Average</span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line">4: invokespecial #3                  // Method Average."&lt;init&gt;":()V</span><br><span class="line"><span class="number">7</span>: astore_1</span><br></pre></td></tr></table></figure><p>为什么要三个指令而不是一个？</p><p>新指令创建对象，但它不会调用构造函数。由于构造函数调用不会返回值，因此在调用对象上的方法之后，对象将被初始化但操作数栈也会弹出对象，因此在初始化对象后我们将无法对该对象执行任何操作。dup指令用于复制堆栈顶部的值，这就是为什么我们需要提前复制引用，以便在构造函数返回后，我们可以将对象实例分配给局部变量或字段。下一条指令可以将对象引用存储：</p><ul><li>astore {N}或astore_{N} - 分配给局部变量，其中{N}是局部变量表中变量的位置。</li><li>putfield - 将值分配给实例字段</li><li>putstatic - 将值赋给静态字段</li></ul><p>虽然是一个构造函数调用，可能更早就会发起调用。比如类的静态初始化，而是由以下指令之一触发：<code>new</code>，<code>getstatic</code>，<code>putstatic</code>或<code>invokestatic</code>。也就是说，如果您创建类的新实例，访问静态字段或调用静态方法，则会触发静态初始化。</p><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>我们在类实例化时调用了初始化方法，该方法是通过invokespecial指令调用的。但是，还有一些用于方法调用的指令：</p><ul><li>invokestatic，这是对类的静态方法的调用。这是最快的方法调用指令。</li><li>invokespecial，指令用于调用构造函数。但它也用于调用同类的私有方法和超类的可访问的方法（比如父类构造器）。</li><li>invokevirtual, 用于调用public，protected和package私有方法（具体类型的实例对象）。</li><li>invokeinterface，当要调用的方法属于接口方法。</li></ul><p><code>invokevirtual</code>和<code>invokeinterface</code>之间有什么区别？为什么不使用<code>invokevirtual</code>搞定一切调用？毕竟接口方法是公开方法。</p><p>这主要更高效的方法调用。例如，<code>invokestatic</code>我们确切地知道要调用哪个方法：它是静态的，它只属于一个类。由于<code>invokespecial</code>有一个有限的选项列表 ，这意味着运行时将更快地找到所需的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">	<span class="title">method</span> <span class="title">method</span>()</span></span><br><span class="line"><span class="class">   </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">  <span class="title">method</span> <span class="title">method</span>()</span></span><br><span class="line"><span class="class">  <span class="title">method</span> <span class="title">methodB</span>()</span></span><br><span class="line"><span class="class">  <span class="title">method</span> <span class="title">methodX</span>()</span></span><br><span class="line"><span class="class">  </span></span><br><span class="line"><span class="class"><span class="title">interface</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">  <span class="title">method</span> <span class="title">public</span>()</span></span><br><span class="line"><span class="class">  </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">  <span class="title">method</span> <span class="title">methodX</span>()</span></span><br></pre></td></tr></table></figure><p>看起来在这种情况<code>B</code>中<code>methodX</code>方法和类<code>C</code>没有任何不同。如果还有另一个类C，它也实现了接口但不属于与B相同的层次结构, 这意味着它在方法解析过程中可以做的事情少于<code>invokevirtual</code>。</p><h3 id="字节码在arthas中的使用"><a href="#字节码在arthas中的使用" class="headerlink" title="字节码在arthas中的使用"></a>字节码在arthas中的使用</h3><p>前面已经讲解足够多的字节码知识，下面我们学习下<code>arthas</code>诊断工具是如何使用字节码技术的。</p><h3 id="装载参数到操作数栈"><a href="#装载参数到操作数栈" class="headerlink" title="装载参数到操作数栈"></a>装载参数到操作数栈</h3><p>在实际方法调用前，会将方法参数装载操作数栈中，<code>AdviceWeaver</code>中提供了方法进入前的钩子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMethodEnter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    codeLockForTracing.lock(<span class="keyword">new</span> CodeLock.Block() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> StringBuilder append = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            _debug(append, <span class="string">"debug:onMethodEnter()"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加载before方法</span></span><br><span class="line">            loadAdviceMethod(KEY_ARTHAS_ADVICE_BEFORE_METHOD);</span><br><span class="line"></span><br><span class="line">            _debug(append, <span class="string">"debug:onMethodEnter() &gt; loadAdviceMethod()"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 推入Method.invoke()的第一个参数</span></span><br><span class="line">            pushNull();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方法参数</span></span><br><span class="line">            loadArrayForBefore();</span><br><span class="line"></span><br><span class="line">            _debug(append, <span class="string">"debug:onMethodEnter() &gt; loadAdviceMethod() &gt; loadArrayForBefore()"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用方法</span></span><br><span class="line">            invokeVirtual(ASM_TYPE_METHOD, ASM_METHOD_METHOD_INVOKE);</span><br><span class="line">            pop();</span><br><span class="line"></span><br><span class="line">            _debug(append, <span class="string">"debug:onMethodEnter() &gt; loadAdviceMethod() &gt; loadArrayForBefore() &gt; invokeVirtual()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    mark(beginLabel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要分析<code>loadArrayForBefore()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadArrayForBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bipush指令加载7到操作数栈顶</span></span><br><span class="line">    push(<span class="number">7</span>);</span><br><span class="line">    <span class="comment">// anewarray指令从栈顶弹出7，创建长度为7的数组</span></span><br><span class="line">    newArray(ASM_TYPE_OBJECT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dup指令复制栈顶引用, 数组引用</span></span><br><span class="line">    dup();</span><br><span class="line">    <span class="comment">// 加载0到栈顶，作为数组索引</span></span><br><span class="line">    push(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 加载adviceId到栈顶</span></span><br><span class="line">    push(adviceId);</span><br><span class="line">    <span class="comment">// 对栈顶整数值装箱(因为是创建Object[])</span></span><br><span class="line">    box(ASM_TYPE_INT);</span><br><span class="line">    <span class="comment">// 将栈顶adviceId存储到数组0位置，Object[0]=adviceId</span></span><br><span class="line">    <span class="comment">// 当前指令会弹出array, index, value</span></span><br><span class="line">    arrayStore(ASM_TYPE_INTEGER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dup指令复制栈顶引用, 数组引用</span></span><br><span class="line">    dup();</span><br><span class="line">    <span class="comment">// 加载1到栈顶，作为数组索引</span></span><br><span class="line">    push(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 加载classloader到栈顶</span></span><br><span class="line">    loadClassLoader();</span><br><span class="line">    <span class="comment">// 将栈顶classloader存储到数组1位置，Object[1]=classloader</span></span><br><span class="line">    <span class="comment">// 当前指令会弹出array, index, value</span></span><br><span class="line">    arrayStore(ASM_TYPE_CLASS_LOADER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dup指令复制栈顶引用, 数组引用</span></span><br><span class="line">    dup();</span><br><span class="line">    <span class="comment">// 加载2到栈顶，作为数组索引</span></span><br><span class="line">    push(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 加载className到栈顶</span></span><br><span class="line">    push(className);</span><br><span class="line">    <span class="comment">// 将栈顶className存储到数组1位置，Object[2]=className</span></span><br><span class="line">    <span class="comment">// 当前指令会弹出array, index, value</span></span><br><span class="line">    arrayStore(ASM_TYPE_STRING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dup指令复制栈顶引用, 数组引用</span></span><br><span class="line">    dup();</span><br><span class="line">    <span class="comment">// 加载3到栈顶，作为数组索引</span></span><br><span class="line">    push(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 加载name到栈顶</span></span><br><span class="line">    push(name);</span><br><span class="line">    <span class="comment">// 将栈顶name存储到数组1位置，Object[3]=name</span></span><br><span class="line">    <span class="comment">// 当前指令会弹出array, index, value</span></span><br><span class="line">    arrayStore(ASM_TYPE_STRING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dup指令复制栈顶引用, 数组引用</span></span><br><span class="line">    dup();</span><br><span class="line">    <span class="comment">// 加载4到栈顶，作为数组索引</span></span><br><span class="line">    push(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 加载方法类型描述符到栈顶</span></span><br><span class="line">    push(desc);</span><br><span class="line">    <span class="comment">// 将栈顶name存储到数组4位置，Object[4]=desc</span></span><br><span class="line">    <span class="comment">// 当前指令会弹出array, index, value</span></span><br><span class="line">    arrayStore(ASM_TYPE_STRING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dup指令复制栈顶引用, 数组引用</span></span><br><span class="line">    dup();</span><br><span class="line">    <span class="comment">// 加载5到栈顶，作为数组索引</span></span><br><span class="line">    push(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 加载this(aload_0)或者null到栈顶</span></span><br><span class="line">    loadThisOrPushNullIfIsStatic();</span><br><span class="line">    <span class="comment">// 将栈顶this或者null存储到数组5位置，Object[5]=this|null</span></span><br><span class="line">    <span class="comment">// 当前指令会弹出array, index, value</span></span><br><span class="line">    arrayStore(ASM_TYPE_OBJECT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dup指令复制栈顶引用, 数组引用</span></span><br><span class="line">    dup();</span><br><span class="line">    <span class="comment">// 加载6到栈顶，作为数组索引</span></span><br><span class="line">    push(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// 加载参数值作为数组放到索引6的位置</span></span><br><span class="line">    loadArgArray();</span><br><span class="line">    arrayStore(ASM_TYPE_OBJECT_ARRAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看到方法调用拦截前<code>arthas</code>会把当前<code>command</code>的<code>adviceId</code>、类、方法、类型描述符和参数值全部保存在数组中。<code>GeneratorAdapter.loadArgArray</code>直接调用的是asm字节码库方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadArgArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取参数个数，压入操作数栈顶</span></span><br><span class="line">    push(argumentTypes.length);</span><br><span class="line">    <span class="comment">// anewarray创建和参数个数等长的对象数组</span></span><br><span class="line">    newArray(OBJECT_TYPE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argumentTypes.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 复制栈顶数组对象引用</span></span><br><span class="line">        dup();</span><br><span class="line">        <span class="comment">// 压入数组当前索引i</span></span><br><span class="line">        push(i);</span><br><span class="line">        <span class="comment">// 使用`&#123;prefix&#125;load`指令加载参数到栈顶</span></span><br><span class="line">        <span class="comment">// 比如整数就会用`iload`指令</span></span><br><span class="line">        loadArg(i);</span><br><span class="line">        <span class="comment">// 对参数装箱</span></span><br><span class="line">        box(argumentTypes[i]);</span><br><span class="line">        <span class="comment">// 存储参数值到当前数组索引i中</span></span><br><span class="line">        arrayStore(OBJECT_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="装载方法调用结果到操作数栈"><a href="#装载方法调用结果到操作数栈" class="headerlink" title="装载方法调用结果到操作数栈"></a>装载方法调用结果到操作数栈</h3><p>和方法调用前一样，我们可以在方法退出时进行字节码拦截，这段代码我们可以在<code>AdviceWeaver</code>中找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMethodExit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isThrow(opcode)) &#123;</span><br><span class="line">        codeLockForTracing.lock(<span class="keyword">new</span> CodeLock.Block() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> StringBuilder append = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                _debug(append, <span class="string">"debug:onMethodExit()"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加载返回对象</span></span><br><span class="line">                loadReturn(opcode);</span><br><span class="line">                _debug(append, <span class="string">"debug:onMethodExit() &gt; loadReturn()"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加载returning方法</span></span><br><span class="line">                loadAdviceMethod(KEY_ARTHAS_ADVICE_RETURN_METHOD);</span><br><span class="line">                _debug(append, <span class="string">"debug:onMethodExit() &gt; loadReturn() &gt; loadAdviceMethod()"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 推入Method.invoke()的第一个参数</span></span><br><span class="line">                pushNull();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加载return通知参数数组</span></span><br><span class="line">                loadReturnArgs();</span><br><span class="line">                _debug(append, <span class="string">"debug:onMethodExit() &gt; loadReturn() &gt; loadAdviceMethod() &gt; loadReturnArgs()"</span>);</span><br><span class="line"></span><br><span class="line">                invokeVirtual(ASM_TYPE_METHOD, ASM_METHOD_METHOD_INVOKE);</span><br><span class="line">                pop();</span><br><span class="line"></span><br><span class="line">                _debug(append, <span class="string">"debug:onMethodExit() &gt; loadReturn() &gt; loadAdviceMethod() &gt; loadReturnArgs() &gt; invokeVirtual()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点我们看下<code>loadReturnArgs</code>中如何使用通过字节码装载参数的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadReturnArgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设字母分别代码以下值：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * r -&gt; return value</span></span><br><span class="line"><span class="comment">     * f -&gt; advice static method  field</span></span><br><span class="line"><span class="comment">     * n -&gt; null</span></span><br><span class="line"><span class="comment">     * a -&gt; array</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当前栈顶的状态： rrfn , rrfn的右方是栈顶</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们要构造的最终结果是：rfna, 代表的含义会回调通知拦截方法f,</span></span><br><span class="line"><span class="comment">     * 传递给方法的2个参数分别为null和array, array中已经保存了</span></span><br><span class="line"><span class="comment">     * 结果r的引用，即array[0]=r</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rrfn  -&gt; rfnrfn</span></span><br><span class="line">    <span class="comment">// 复制栈顶fn并且插入到栈顶第3个元素之后</span></span><br><span class="line">    dup2X1();</span><br><span class="line">    <span class="comment">// rfnrfn -&gt; rfnr</span></span><br><span class="line">    <span class="comment">// 弹出栈顶2个元素</span></span><br><span class="line">    pop2();</span><br><span class="line">    <span class="comment">// rfnr   -&gt; rfnr1</span></span><br><span class="line">    <span class="comment">// 压入1到操作数栈顶</span></span><br><span class="line">    push(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// rfnr1 -&gt; rfnra</span></span><br><span class="line">    <span class="comment">// 弹出栈顶1并创建数组压入栈顶</span></span><br><span class="line">    newArray(ASM_TYPE_OBJECT);</span><br><span class="line">    <span class="comment">// rfnra  -&gt; rfnraa</span></span><br><span class="line">    <span class="comment">// 复制栈顶数组引用</span></span><br><span class="line">    dup();</span><br><span class="line">    <span class="comment">// rfnraa -&gt; rfnaaraa</span></span><br><span class="line">    <span class="comment">// 复制栈顶aa并且插入到栈顶第3个元素之后</span></span><br><span class="line">    dup2X1();</span><br><span class="line">    <span class="comment">// rfnaaraa -&gt; rfnaar</span></span><br><span class="line">    <span class="comment">// 弹出栈顶的2个元素值</span></span><br><span class="line">    pop2();</span><br><span class="line">    <span class="comment">// rfnaar   -&gt; rfnaar0</span></span><br><span class="line">    <span class="comment">// 压入数组索引0到栈顶</span></span><br><span class="line">    push(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// rfnaar0  -&gt; rfnaa0r</span></span><br><span class="line">    <span class="comment">// 交换栈顶2个元素值</span></span><br><span class="line">    swap();</span><br><span class="line">    <span class="comment">// rfnaa0r -&gt; rfna</span></span><br><span class="line">    <span class="comment">// 将r值保存在数组索引0位置，array[0]=r，并弹出数组</span></span><br><span class="line">    arrayStore(ASM_TYPE_OBJECT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面给出了详细的字节码推演，可以看到字节码在<code>arthas</code>中核心的应用场景点。当然解析<code>arthas</code>超过这个小节的重点，后面有时间我会另外章节讲解<code>arthas</code>原理。</p><h3 id="ASM介绍和学习"><a href="#ASM介绍和学习" class="headerlink" title="ASM介绍和学习"></a>ASM介绍和学习</h3><p>这里主要简单介绍<code>asm</code>库的简单使用并会给出有用的插件帮助深入研究字节码的技巧，授人以鱼不如授人以渔，哈哈。</p><p>时间倒转，再回到经典的<code>Hello World</code>程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yiji@apache.org</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成与<code>HelloWorld</code>相对应的字节码的最常见方案是创建ClassWriter，访问类似字段，方法等，并在生成类描述后写出最终字节。</p><p>首先，先构造ClassWriter实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassWriter cw = <span class="keyword">new</span> ClassWriter（</span><br><span class="line">    ClassWriter.COMPUTE_MAXS | </span><br><span class="line">    ClassWriter.COMPUTE_FRAMES）;</span><br></pre></td></tr></table></figure><p><code>COMPUTE_MAXS</code>告诉<code>ASM</code>自动计算最大堆栈大小和方法的最大局部变量数。<code>COMPUTE_FRAMES</code>告诉ASM从头开始自动计算方法的堆栈映射帧。</p><p>定义一个类我们必须调用<code>ClassWriter.visit()</code> 的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cw.visit(V1_8, ACC_PUBLIC + ACC_SUPER, <span class="string">"HelloWorld"</span>, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>接下来，我们生成默认构造函数和main方法。如果跳过生成默认构造函数，则不会发生任何错误，但生成手动生成一个更完备一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mv = cw.visitMethod(ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">mv.visitCode();</span><br><span class="line">mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">mv.visitMethodInsn(INVOKESPECIAL, <span class="string">"java/lang/Object"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</span><br><span class="line">mv.visitInsn(RETURN);</span><br><span class="line">mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">mv.visitEnd();</span><br></pre></td></tr></table></figure><p>我们首先使用该<code>visitMethod()</code> 方法创建了构造函数。接下来，要通过调用<code>visitCode()</code>方法开始生成构造函数的代码体。最后我们调用<code>visitMaxs()</code>- 这是要求ASM重新计算最大堆栈大小。<code>ASM</code>可以自动完成计算，我们可以将随机参数传递给<code>visitMaxs()</code>方法。最后，调用<code>visitEnd()</code>结束构造函数方法体。</p><p>以下是main方法的<code>ASM</code>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, <span class="string">"main"</span>, <span class="string">"([Ljava/lang/String;)V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">mv.visitCode();</span><br><span class="line">mv.visitFieldInsn(GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">mv.visitLdcInsn(<span class="string">"Hello world, I'm asm !"</span>);</span><br><span class="line">mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line">mv.visitInsn(RETURN);</span><br><span class="line">mv.visitMaxs(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">mv.visitEnd();</span><br></pre></td></tr></table></figure><p>通过<code>visitMethod()</code>再次调用，给出方法修饰符、方法名称、方法类型描述符、签名和异常生成新方法定义。然后调用<code>visitCode()</code>，<code>visitMaxs()</code>和<code>visitEnd()</code>方法完成代码的编写。<code>visitFieldInsn</code>会最终转换成<code>getstatic</code>指令，<code>visitLdcInsn</code>会最终转换<code>ldc</code>加载常量池引用。</p><p>最终给出可出可运行的字节码应用程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassWriter;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.MethodVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yiji@apache.org</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldDump</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldDump</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bytes = bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] ba = <span class="keyword">this</span>.bytes;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, ba, <span class="number">0</span>, ba.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        HelloWorldDump loader = <span class="keyword">new</span> HelloWorldDump(dump());</span><br><span class="line">        Class clazz = loader.findClass(<span class="string">"HelloWorld"</span>);</span><br><span class="line"></span><br><span class="line">        Method main = clazz.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[]&#123;String[].class&#125;);</span><br><span class="line">        main.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> String[<span class="number">0</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] dump() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS |</span><br><span class="line">                ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">        MethodVisitor mv;</span><br><span class="line"></span><br><span class="line">        cw.visit(V1_8, ACC_PUBLIC + ACC_SUPER, <span class="string">"HelloWorld"</span>, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            mv = cw.visitMethod(ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            mv.visitCode();</span><br><span class="line">            mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKESPECIAL, <span class="string">"java/lang/Object"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</span><br><span class="line">            mv.visitInsn(RETURN);</span><br><span class="line">            mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            mv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, <span class="string">"main"</span>, <span class="string">"([Ljava/lang/String;)V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            mv.visitCode();</span><br><span class="line">            mv.visitFieldInsn(GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">            mv.visitLdcInsn(<span class="string">"Hello world, I'm asm !"</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line">            mv.visitInsn(RETURN);</span><br><span class="line">            mv.visitMaxs(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">            mv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        cw.visitEnd();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析字节码工具"><a href="#分析字节码工具" class="headerlink" title="分析字节码工具"></a>分析字节码工具</h3><p>想写好完备的字节码程序对程序员能力要求非常高，幸好<code>asm</code>提供了自动生成字节码代码工具，我们熟悉的<code>intellij idea</code>也有对应的插件。学习使用ASM的最佳方法是编写一个等同于想要生成的Java源文件，然后使用<code>ASM Bytecode Viewer</code>插件（或ASMifier工具）的ASMifier模式来查看等效的ASM代码。如果要实现类转换器，请编写两个Java源文件（转换前），并在ASMifier模式下使用插件的比较视图来比较等效的ASM代码。</p><p><img src="https://zonghaishang.github.io/images/1540374041117.png" class="pretty"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>研究字节码的动机主要来源于<code>greys</code>，当时想研究它的原理写一套更好用的诊断工具，但是后来发现<code>arthas</code>用起来满足需要，就放弃了重新开发的想法，刚好把精力再投回<code>Dubbo</code>。</p><p>这里主要记录字节码学习过程，希望能帮助更多对这块感兴趣的同学，同时也能加深对jvm字节码的理解，为后续深入研究JVM也有帮助。</p><div class="post-announce">感谢您的阅读，本文由 <a href="https://zonghaishang.github.io">诣极的博客</a> 版权所有。如若转载，请注明出处：诣极的博客（<a href="https://zonghaishang.github.io/2018/10/22/理解字节码原理/">https://zonghaishang.github.io/2018/10/22/理解字节码原理/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/10/01/Spring杂谈-循环依赖导致Dubbo服务无法被正确代理/" title="Dubbo无法处理Spring代理对象"><i class="iconfont icon-prev"></i>Dubbo无法处理Spring代理对象</a></div><div class="post__prev post__prev--right"><a href="/2018/10/26/理解arthas原理/" title="理解arthas原理">理解arthas原理<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">商宗海，花名诣极，开源dubbo核心开发者之一。曾就职于阿里巴巴、金蝶中国。现就职于有赞科技，担任dubbo框架技术负责人，参与中间件开发，长期活跃在dubbo社区。</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/工作经历/">工作经历</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/jvm/">jvm</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/asm/">asm</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/arthas/">arthas</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Spring杂谈/">Spring杂谈</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Fastjson源码解析/">Fastjson源码解析</a><span class="block-list-count">11</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/10/26/Ubuntu18.0.4.1编译openjdk8/" title="Ubuntu18.0.4.1编译openjdk8"><div class="item__cover"><img src="/images/jdk.jpg" alt="Ubuntu18.0.4.1编译openjdk8"></div><div class="item__info"><h3 class="item__title">Ubuntu18.0.4.1编译openjdk8</h3><span class="item__text">2018-10-26</span></div></a></li><li class="latest-post-item"><a href="/2018/10/26/理解arthas原理/" title="理解arthas原理"><div class="item__cover"><img src="/images/arthas.png" alt="理解arthas原理"></div><div class="item__info"><h3 class="item__title">理解arthas原理</h3><span class="item__text">2018-10-26</span></div></a></li><li class="latest-post-item"><a href="/2018/10/22/理解字节码原理/" title="理解Java字节码原理"><div class="item__cover"><img src="/images/asm.png" alt="理解Java字节码原理"></div><div class="item__info"><h3 class="item__title">理解Java字节码原理</h3><span class="item__text">2018-10-22</span></div></a></li><li class="latest-post-item"><a href="/2018/10/01/Spring杂谈-循环依赖导致Dubbo服务无法被正确代理/" title="Dubbo无法处理Spring代理对象"><div class="item__cover"><img src="/images/spring.jpg" alt="Dubbo无法处理Spring代理对象"></div><div class="item__info"><h3 class="item__title">Dubbo无法处理Spring代理对象</h3><span class="item__text">2018-10-01</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Dubbo框架问题/">Dubbo框架问题</a></li><li class="tag-item"><a class="tag-link" href="/tags/Fastjson源码解析/">Fastjson源码解析</a></li><li class="tag-item"><a class="tag-link" href="/tags/Spring杂谈/">Spring杂谈</a></li><li class="tag-item"><a class="tag-link" href="/tags/arthas/">arthas</a></li><li class="tag-item"><a class="tag-link" href="/tags/asm/">asm</a></li><li class="tag-item"><a class="tag-link" href="/tags/jvm/">jvm</a></li><li class="tag-item"><a class="tag-link" href="/tags/jvm-openjdk/">jvm, openjdk</a></li><li class="tag-item"><a class="tag-link" href="/tags/openjdk/">openjdk</a></li><li class="tag-item"><a class="tag-link" href="/tags/工作经历/">工作经历</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">诣极的博客，主要用于分享日常学习和工作的一些心得总结。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Hangzhou, Zhejiang Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>yiji@apache.org</span></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="" target="_blank">Blog</a> 2018 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/zonghaishang" target="_blank">诣极</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/zonghaishang" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:yiji@apache.org" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="https://zonghaishang.github.io/" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>